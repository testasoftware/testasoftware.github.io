{"componentChunkName":"component---src-pages-blog-markdown-remark-frontmatter-slug-tsx","path":"/blog/2017-07-03-web-application-primer-in-haskell-programming-language/","result":{"data":{"markdownRemark":{"html":"<p>In this series, we're going to work our way through the development stack bottom-up. So to kick off our Haskell web application primer we're going to start with Haskell and core Game of Life code.<!--more--></p>\n<ul>\n<li>Heroku\n<ul>\n<li>Docker\n<ul>\n<li>React + ES6</li>\n<li>Snap Framework + Heist + Websockets</li>\n<li><strong>Haskell</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Programming Language: Haskell</h3>\n<p>I'm relatively new to it, but I love Haskell! I drank the kool-aid. As mentioned previously Haskell is the foundation we're building on. When it comes to Haskell I'm certainly a hobbyist - so don't take any code provided as gospel or even best practice. This is just what I did to get a web application up and running in a manner that would be repeatable in the future on other projects.</p>\n<p>We'll talk more about the web application pieces in the next post. For this post we're really only going to focus on the core functionality of our Game of Life clone.</p>\n<h3>The Game of Haskell: Our Core Code Base</h3>\n<p>I'm going to assume that the reader already has a working knowledge of Conway's Game of Life. If you're not sure what the Game of Life is, you can checkout the <a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\">wikipedia link here</a>.</p>\n<p>Moving on ...</p>\n<p>I've broken down two core types (Type Synonyms more specifically) for this program: a cell and a board</p>\n<ul>\n<li>A cell is simply a tuple that maintains and <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> position.</li>\n<li>A board is a list of the living cells in the current generation.</li>\n</ul>\n<p>In Haskell these types were very easy to define using two Type Synonyms:</p>\n<script src=\"https://gist.github.com/stesta/2dbe61d87de8e552f2bdb8a45e2e9971.js\"></script>\n<p>The board's definition is an effort to avoid a fixed array size for the game. By only tracking the living cells we can manage a board that is arbitrarily large. The downside to this approach is that the calculations and rendering can slow down when there are high number of living cells. As of yet, I've made no effort to correct for that problem.</p>\n<p>What this means for our code is that we are unable to just loop through a fixed board array and run our life/death/birth calculation for each node in that board. Instead, we need to run that calculation for every living cell and each of their dead neighbors since those dead neighbors stand a chance of being \"born\".</p>\n<p>This approach makes things particularly concise to define in Haskell. I'm sure this could be code golfed to something more cleverly implemented, but here's the approach I took.</p>\n<p>The live or die code is straight forward. I wrote a function that takes in a board and a single cell and returns a boolean as to whether that particular cell should live or die (or be born) for the next generation.</p>\n<script src=\"https://gist.github.com/stesta/02e0cfa3267818ec89c29174824d5390.js\"></script>\n<p>As you can see from the code, using guards we can very clearly define the standard set of rules for the Game of Life. Ultimately, everything boils down to whether or not the cell is alive and the alive neighbor count (<code class=\"language-text\">ns</code>). There are a few helper functions being used - namely: <code class=\"language-text\">isAlive</code> and <code class=\"language-text\">aliveNeighborCount</code>. You can review the full implementation in <a href=\"https://github.com/stesta/GameOfLife/blob/master/src/GameOfHaskell/Core.hs\">the source code</a>. They are fairly straightforward -  <code class=\"language-text\">isAlive</code> basically looks to see if the the cell exists on the current board and <code class=\"language-text\">aliveNeighboardCount</code> makes that same check against all of the neighboring cells.</p>\n<p>Once we have our <code class=\"language-text\">liveOrDie</code> function defined it was easy enough to use the State Monad to calculate what the next generation of a board should look like and put that into the next state.</p>\n<script src=\"https://gist.github.com/stesta/1543868341e5919041c09f3b2974b810.js\"></script>\n<p>We get all of the surrounding dead neighbors. For each of the dead neighbors and the currently living cells, we filter out only the cells that should live for the next generation and that becomes our new board.</p>\n<p>The last thing I did was to create one final function that again uses a State Monad to compute not just a single generation, but also recurisively defines an infinite list of all future generations. Haskell's laziness for the win!</p>\n<script src=\"https://gist.github.com/stesta/9ec842a83700a8e955f68159aa596a5f.js\"></script>\n<p>If you've pulled down my <a href=\"https://github.com/stesta/GameOfLife\">source code</a> you can test all this by loading Core.hs into the ghci</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token operator\">></span> ghci\r\nGHCi, version <span class=\"token number\">8.0</span>.2: http://www.haskell.org/ghc/  :? <span class=\"token keyword\">for</span> <span class=\"token builtin class-name\">help</span>\r\n\r\nPrelude<span class=\"token operator\">></span> :l src/GameOfHaskell/Core.hs</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Then use <code class=\"language-text\">evalState</code> and the List Index (subscript) operator <code class=\"language-text\">!!</code> to access individual generations of a board. The example below loads in and accesses generations from the \"acorn\" pattern:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token comment\">-- load in a game state</span>\r\n<span class=\"token operator\">*</span><span class=\"token constant\">GameOfHaskell.Core</span><span class=\"token operator\">></span> <span class=\"token keyword\">let</span> <span class=\"token hvariable\">game</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">evalState</span> <span class=\"token hvariable\">generations</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>  \r\n\r\n<span class=\"token comment\">-- access individual generations </span>\r\n<span class=\"token operator\">*</span><span class=\"token constant\">GameOfHaskell.Core</span><span class=\"token operator\">></span> <span class=\"token hvariable\">game</span><span class=\"token operator\">!!</span><span class=\"token number\">0</span> \r\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> \r\n<span class=\"token operator\">*</span><span class=\"token constant\">GameOfHaskell.Core</span><span class=\"token operator\">></span> <span class=\"token hvariable\">game</span><span class=\"token operator\">!!</span><span class=\"token number\">1</span>\r\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The only other code I've really included was some basic Game of Life patterns. These are defined with an origin of (0,0) being the upper-left hand cell of the grid. I've included a simple <code class=\"language-text\">translatePattern</code> function to translate the pattern to some other point on the board. You can see all that pattern code here.</p>\n<p>Next up we'll talk about how the web framework was set up around this core code.</p>","frontmatter":{"date":"July 03, 2017","slug":"2017-07-03-web-application-primer-in-haskell-programming-language","title":"Web Application Primer in Haskell - Haskell","image":"/assets/images/blog/thumbnails/haskell.png"}}},"pageContext":{"id":"857536f2-6651-5d08-bc85-f606ab541cdb","frontmatter__slug":"2017-07-03-web-application-primer-in-haskell-programming-language","__params":{"frontmatter__slug":"2017-07-03-web-application-primer-in-haskell-programming-language"}}},"staticQueryHashes":[]}