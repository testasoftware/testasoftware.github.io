{
    "componentChunkName": "component---src-pages-blog-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/2017-07-27-web-application-primer-in-haskell-web-framework/",
    "result": {"data":{"markdownRemark":{"html":"<p>There are plenty of choices when it comes to Haskell web frameworks: yesod, spock, snap, happstack - just to name a few.<!--more--> The <a href=\"https://wiki.haskell.org/Web/Frameworks\">Haskell Wiki</a> provides a list of descriptions and differences between some of the web frameworks out there.</p>\n<ul>\n<li>Heroku\n<ul>\n<li>Docker\n<ul>\n<li>React + ES6</li>\n<li><strong>Snap Framework + Heist + Websockets</strong></li>\n<li><a href=\"/blog/2017-07-03-web-application-primer-in-haskell-programming-language\">Haskell</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>Web Framework: Snap Framework</h2>\n<p>I spent a little bit of time researching the various frameworks to determine if there was an outright favorite. Nope. It was a bit of a tough decision. I wanted a framework that was easy to get up and running quickly and would be extensible enough for future projects. Yesod seemed like a great option, but they lost me on the <a href=\"https://www.yesodweb.com/book/shakespearean-templates\">Shakespearean Template Languages</a>. That particular flavor of templating just isn't for me. Maybe I'll change my mind in the future. I suggest you decide for yourself what works best for you and your situation.</p>\n<p>Ultimately, I landed on the <a href=\"http://snapframework.com/\">Snap Framework</a>. For me, the Snap felt lightweight enough to get up and running quickly without too much ceremony. Getting an HTTP server up and running along with some simple routing is a breeze. Additionally, Snap's templating system (Heist) felt very natural to me.</p>\n<p>As far as extensibility goes, they have a concept of <a href=\"http://snapframework.com/snaplets\">Snaplets</a>. Snaplets allow you to build self-contained bits of additional functionality. When it comes time to add in things like sessions and authentication you can do so easily via built-in Snaplets (or write your own). Third-party Snaplets seemed readily available and easy to find.</p>\n<p>On to the code!</p>\n<h3>Setting up a Basic HTTP Server</h3>\n<p>For the basic Snap site setup I have chosen to break things out into three files in order to have a clear separation of concerns. To be fair I saw this convention somewhere... liked it... and subsequently ripped it off! :)</p>\n<p>The three files summarize as follows:</p>\n<p><strong>Main.hs</strong></p>\n<p>The entry point for our application is very simple. All we're doing here is serving up our website via the <code class=\"language-text\">serveSnaplet</code> function which takes in a server configuration and a snaplet initializer. For the server configuration we're just using the <code class=\"language-text\">defaultConfig</code>. The snaplet initializer (<code class=\"language-text\">siteInit</code>) is defined a little further below.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">main</span> <span class=\"token operator\">::</span> <span class=\"token constant\">IO</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">serveSnaplet</span> <span class=\"token hvariable\">defaultConfig</span> <span class=\"token hvariable\">siteInit</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><strong>Application.hs</strong></p>\n<p>This file defines a data structure we can use to hold the state for our application. The App data structure will contain the state of all the snaplets we intend to user and in-turn wrap them all up as a Snaplet. Note that I don't understand the technical reasons, but the field names all need to begin with an underscore. Following that up with the <code class=\"language-text\">makeLenses</code> helper lets us call those field names <em>without</em> an underscore throughout the rest of our application.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">App</span> <span class=\"token operator\">=</span> <span class=\"token constant\">App</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">_heist</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Snaplet</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Heist</span> <span class=\"token constant\">App</span><span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token hvariable\">makeLenses</span> ''<span class=\"token constant\">App</span>\n\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">HasHeist</span> <span class=\"token constant\">App</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">heistLens</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">subSnaplet</span> <span class=\"token hvariable\">heist</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token constant\">AppHandler</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Handler</span> <span class=\"token constant\">App</span> <span class=\"token constant\">App</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The Application.hs is also where we've instanced out Heist and added a convenience type synonym called <code class=\"language-text\">AppHandler</code>.</p>\n<p><strong>Site.hs</strong></p>\n<p>Finally, we define a Site.hs to house our Snaplet initializer to initialize our site. When making this top level Snaplet the first the we end up doing is to initialize all of the nested Snaplets our site will use. In this case we're only initializing the Heist Snaplet for templating. Then there's some basic routing. Finally, a return of the resulting <code class=\"language-text\">App</code> state data structure.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">siteInit</span> <span class=\"token operator\">::</span> <span class=\"token constant\">SnapletInit</span> <span class=\"token constant\">App</span> <span class=\"token constant\">App</span>\n<span class=\"token hvariable\">siteInit</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">makeSnaplet</span> <span class=\"token string\">\"app\"</span> <span class=\"token string\">\"An snaplet example application.\"</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">$</span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">h</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">nestSnaplet</span> <span class=\"token string\">\"\"</span> <span class=\"token hvariable\">heist</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">heistInit</span> <span class=\"token string\">\"templates\"</span>\n    <span class=\"token hvariable\">addRoutes</span> <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"/\"</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">render</span> <span class=\"token string\">\"index.tpl\"</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"gameoflife\"</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">gameOfLife</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"/scripts\"</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">serveDirectory</span> <span class=\"token string\">\"assets/scripts\"</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"/styles\"</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">serveDirectory</span> <span class=\"token string\">\"assets/styles\"</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">render</span> <span class=\"token string\">\"404.tpl\"</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">]</span>\n    <span class=\"token builtin\">return</span> <span class=\"token operator\">$</span> <span class=\"token constant\">App</span> <span class=\"token hvariable\">h</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Setting up Websockets</h3>\n<p>I could have used REST here. It is easy to create an REST API as a Snaplet. For the purposes for the Game of Haskell, however, I needed (wanted) something a little more real-time.</p>\n<p>Websockets are the no-brainer client-server communication protocol for the web. Packages are available to add websocket support in for Haskell as well as a corresponding Snaplet to plug in to our application.</p>\n<p>If you review our site initializer you will find the <code class=\"language-text\">gameoflife</code> route. It points to an <code class=\"language-text\">AppHandler</code>. The handler runs a web socket <code class=\"language-text\">ServerApp</code>. The server app continually listens for new messages, expecting an integer to be sent across the wire, and returns the corresponding game state. The game state itself is packaged up as JSON using the <a href=\"https://github.com/haskell/aeson\">aeson</a> Haskell library.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token comment\">-- | Game of Life handler</span>\n<span class=\"token operator\">--------------------------------------------------------------------------------</span>\n<span class=\"token hvariable\">gameOfLife</span> <span class=\"token operator\">::</span> <span class=\"token constant\">AppHandler</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token hvariable\">gameOfLife</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">WS.runWebSocketsSnap</span> <span class=\"token hvariable\">gameOfLifeApp</span> \n\n\n<span class=\"token comment\">-- | Game of Life server app</span>\n<span class=\"token comment\">-- set an initial board state and continually listen for</span>\n<span class=\"token comment\">-- the next msg::Int (corresponds to a board generation #) </span>\n<span class=\"token comment\">-- sends back to the client the requested board via JSON array</span>\n<span class=\"token operator\">--------------------------------------------------------------------------------</span>\n<span class=\"token hvariable\">gameOfLifeApp</span> <span class=\"token operator\">::</span> <span class=\"token constant\">WS.ServerApp</span>\n<span class=\"token hvariable\">gameOfLifeApp</span> <span class=\"token hvariable\">pending</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">do</span> \n    <span class=\"token hvariable\">conn</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">WS.acceptRequest</span> <span class=\"token hvariable\">pending</span>\n    <span class=\"token keyword\">let</span> <span class=\"token hvariable\">game</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">evalState</span> <span class=\"token hvariable\">generations</span> <span class=\"token hvariable\">acorn</span>\n    <span class=\"token hvariable\">forever</span> <span class=\"token operator\">$</span> <span class=\"token keyword\">do</span>\n        <span class=\"token hvariable\">msg</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">WS.receiveData</span> <span class=\"token hvariable\">conn</span>\n        <span class=\"token keyword\">let</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">read</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">T.unpack</span> <span class=\"token hvariable\">msg</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span>\n        <span class=\"token hvariable\">WS.sendTextData</span> <span class=\"token hvariable\">conn</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">encode</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">game</span><span class=\"token operator\">!!</span><span class=\"token hvariable\">g</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Templating via Heist</h3>\n<p>For webpage and HTML templating <a href=\"http://snapframework.com/docs/tutorials/heist\">Heist</a> was a natural choice because it was developed by the same folks who wrote Snap and you get it bundled for free. Heist as a template engine was a selling point for me regarding Snap. The <code class=\"language-text\">bind</code> and <code class=\"language-text\">apply-content</code> features make it possible to build a series of nested templates. When you couple all of that with <code class=\"language-text\">splices</code>, which basically let you call Haskell code from your templates, you have a really powerful system.</p>","frontmatter":{"date":"July 27, 2017","slug":"2017-07-27-web-application-primer-in-haskell-web-framework","title":"Web Application Primer in Haskell - Web Framework","image":"/assets/images/blog/thumbnails/haskell.png"}}},"pageContext":{"id":"117d1d7a-119a-5d95-815c-ed19f042674f","frontmatter__slug":"2017-07-27-web-application-primer-in-haskell-web-framework","__params":{"frontmatter__slug":"2017-07-27-web-application-primer-in-haskell-web-framework"}}},
    "staticQueryHashes": []}